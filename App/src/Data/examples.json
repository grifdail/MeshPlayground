[
    {
        "name": "Volume",
        "code": "noiseSeed(random())\r\n\r\n//First we set the color;\r\nconst palette = randomPalette();\r\nprint(palette.paletteName);\r\nsetBackgroundColor(palette[0]);\r\n\r\n\r\nconst genericSphere = (x,y,z, radius, center) => Vector3.sqrDistance(new Vector3(x,y,z), center)<(radius*radius);\r\n//The volume is defined by a function that return if the given point in the range [0,1] is inside the volume;\r\nconst volumeFunction = (...params) =>{\r\n    if(params.some(x => x<0 || x>1)) {\r\n        return false\r\n    }\r\n    return genericSphere(...params, 0.4+perlin3(params[0]*1,params[1]*5+10,params[2]*3)*0.1,  Vector3.all(0.5));\r\n};\r\n//The color function take a point in [0,1] and return the color at that point\r\nconst colorFunction = (x,y,z) => lerpArray(palette, remapZeroOne(perlin3(x*2,y,z*3)), Color.lerpRGB);\r\n\r\n\r\n//The ConvexVolume primite convert the volume to a mesh.\r\n//The mesh doesn't have to be convex but it can't have hole.\r\n//That function can be pretty slow. Especialy with large subdivision count and small smoothness\r\n//It work by \"shrinking and wrapping\" a subdivied cube around a volume;\r\nconst conv = new ConvexVolume(25, (x,y,z) => volumeFunction(1-x,y,z), colorFunction, 0.00001);\r\naddMesh(conv, new Vector3(25,0,0), Quaternion.identity(), Vector3.all(2));\r\n\r\n//The VoxelizedVolume primite render a volume as a somewhat blocky mesh\r\n//A large resolution will  make the mesh appear smoother but it will be slower\r\n//It work by evaluation every cube.\r\nconst vox = new VoxelizedVolume(50,volumeFunction, colorFunction);\r\naddMesh(vox, new Vector3(-25,0,0));\r\n"
    },
    {
        "name": "flower",
        "code": "\r\nfunction createFlower(palette) {\r\n    const petalRatio = 0.4;\r\n    const midPetalElevationRatio = 0.6;\r\n    for(var j = 0; j<palette.length; j++) {\r\n        setColor(palette[j]);\r\n        const petalElevation = 10+pow(j,2.1)*0.5;\r\n        const count = 10-j;\r\n        const petalLength = 20-pow(j,1.1)*3;\r\n        const petalWidth = 5 -j*0.7\r\n        for(var i =0; i<=count; i+=1) {\r\n            push();\r\n            rotate(0,i/count*TAU,0);\r\n\r\n            addDoubleFacedQuad(\r\n                Vector3.zero(),\r\n                new Vector3(-petalWidth,midPetalElevationRatio*petalElevation,petalRatio*petalLength),\r\n                new Vector3(0,petalElevation,petalLength),\r\n                new Vector3(petalWidth,midPetalElevationRatio*petalElevation,petalRatio*petalLength) );\r\n            pop()\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction addDoubleFacedQuad(a,b,c,d) {\r\n    addQuad(a,b,c,d);\r\n    addQuad(a,d,c,b);\r\n}\r\n\r\ntranslate(0,-20,0)\r\nsetBackgroundColor(ColorPalettes.Wild[1])\r\ncreateFlower(ColorPalettes.Ice);\r\n"
    },
    {
        "name": "heightmap",
        "code": "// If you return a Promise, the mesh generator will wait for the promise\r\n// to resolve before calculating the mesh.\r\n// This allow you to import data such as texture\r\n// You can use these texture as an height map for instance\r\n\r\n// loadSampler take an url and resolve with a sampling function\r\n// the sampler take u and v parameters (in the range [0,1]) and return the color\r\n// of that pixel at that point as an array [red, green, blue, alpha] (in the\r\n// range [0,255]). No interpolation is used yet while sampling.\r\n\r\n// Note that the picture must be served from a server allowing cross origin\r\n// request ( see https://en.wikipedia.org/wiki/Cross-origin_resource_sharing )\r\n\r\n// This code can be pretty due to the image loading and the huge ParametricMesh\r\n\r\n\r\nreturn loadSampler(\"examples_ressources/heightmap.png\").then(sampler=> {\r\n    var p  = new ParametricMesh(255,255,(u,v) => {\r\n        var color = sampler(u,v);\r\n        var greyScale = color.l; //Remove alpha and convert to greyscale\r\n        let height = greyScale //We normalize the calculated depth\r\n        return new Vector3(u*100,height*10,v*100)\r\n    })\r\n\r\n    addFaces(p);\r\n});\r\n"
    },
    {
        "name": "nightsky",
        "code": "const getHeight = (u,v) => remapZeroOne(perlin2(u,v))*50;\r\nconst uvToV2 = v1 => new Vector3(v1.x,0,v1.y);\r\nconst mapWidth = 500;\r\nrandomSeed(16);\r\nnoiseSeed(15);\r\nsetBackgroundColor(Pico8Colors.darkBlue.toString())\r\naddFloor();\r\nfor(let i = 0; i<10; i++) {\r\n    addTree(uvToV2(randomPointInsideCircle()));\r\n}\r\nfor(let i = 0; i<100; i++) {\r\n  addStar();\r\n}\r\n\r\nfunction addFloor() {\r\n  push();\r\n  translate(-mapWidth*0.5,0,-mapWidth*0.5);\r\n  addFaces(new ParametricMesh(15,15,(u,v) => new Vector3(u*mapWidth,getHeight(remapMinusOneOne(u),remapMinusOneOne(v)),v*mapWidth), Pico8Colors.darkGreen));\r\n  pop();\r\n}\r\n\r\nfunction addTree(pos) {\r\n    push();\r\n\r\n    const trunk = new Box(5,Pico8Colors.brown, 1, 3, 1);\r\n    const origin = getPosForUv(pos).add(new Vector3(0,5,0));\r\n\r\n    translate(origin);\r\n    addFaces(trunk);\r\n\r\n    let height = 6;\r\n    for(let i = 0; i<3;i++) {\r\n        translate(new Vector3(0,height,0));\r\n        rotate(0,random()*TAU,0)\r\n        height+=1;\r\n        addFaces(addPyramid(6,15,15-i*3, Pico8Colors.darkGreen))\r\n    }\r\n    pop();\r\n}\r\n\r\nfunction addPyramid(sides, height = 1, radius = 1, color=0xffffff) {\r\n    const m = new Mesh();\r\n    m.setColor(color);\r\n    for(let i =0; i< sides; i++) {\r\n        const ti = i/sides*TAU;\r\n        const tin = (1+i)/sides*TAU;\r\n        const p1 = new Vector3(cos(ti) * radius, 0, sin(ti)*radius);\r\n        const p2 = new Vector3(cos(tin) * radius, 0, sin(tin)*radius);\r\n        m.addFace(Vector3.zero(), p1, p2);\r\n        m.addFace(Vector3.up().scale(height),p2,p1)\r\n    }\r\n    return m;\r\n}\r\n\r\nfunction getPosForUv(pos) {\r\n    const height = getHeight(pos.x,pos.z);\r\n    pos = pos.scale(mapWidth*0.5);\r\n    pos.y=height;\r\n    return pos;\r\n}\r\n\r\nfunction addStar() {\r\n  push();\r\n  translate(randomPointOnSphere().scale(mapWidth*0.7))\r\n  addFaces(new ParametricSphere(4,3,randomRange(1,3)))\r\n  pop();\r\n}\r\n"
    },
    {
        "name": "texture",
        "code": "\r\n// Mesh Playground support basic texturing\r\n// Box have a default UV mapping\r\n\r\nvar box = new Box(15);\r\naddFaces(box);\r\n\r\nreturn loadImage(\"examples_ressources/tile.png\").then(img => {\r\n   setTexture(img);\r\n});\r\n"
    },
    {
        "name": "tilemap",
        "code": "// Mesh Playground support basic texturing\r\n// the tile function can be used to simplify uv creation when dealing with tilemap;\r\n// We need to redefine the cube UV as the default use the whole image.\r\n\r\n// tile take an the number of column and row in a tile map, along with the tile\r\n// coordinate and return the uv data info as an array\r\n// [top left corner, top right corner, bottom right corner, bottom left corner]\r\n\r\n//We create a sampler so we dont have to input column and row every time\r\nconst tileSampler = (x,y) => tile(2,2,x,y);\r\n\r\nvar box = new Box(15);\r\n\r\nbox.calculateFaceWithTile = function() {\r\n    this.clearFaces();\r\n    // We can use es6 opperator to go faster\r\n    this.addQuad(this.LTB, this.RTB, this.RBB, this.LBB, ...tileSampler(0,0)); // you can pass the tile coordinate on the grid\r\n    this.addQuad(this.LTF, this.LTB, this.LBB, this.LBF, ...tileSampler(0,0));\r\n    this.addQuad(this.LTF, this.RTF, this.RTB, this.LTB, ...tileSampler(1,0));\r\n    this.addQuad(this.RTB, this.RTF, this.RBF, this.RBB, ...tileSampler(0,0));\r\n    this.addQuad(this.RTF, this.LTF, this.LBF, this.RBF, ...tileSampler(0,0));\r\n    this.addQuad(this.LBB, this.RBB, this.RBF, this.LBF, ...tileSampler(3)); // You can also give the tile id\r\n}\r\n\r\nbox.calculateFaceWithTile();\r\naddFaces(box);\r\n\r\nreturn loadImage(\"examples_ressources/tiles.png\").then(img => {\r\n   setTexture(img);\r\n});\r\n"
    }
]